def main():
    n = int(input())
    # 계단이 1개일때는 그냥 첫번째 받은 값 출력 후 종료
    if n == 1:
        print(int(input()))
        return

    steps = [0]  # steps[0]: dummy value
    for _ in range(n):
        steps.append(int(input()))
    # d[i][j]: 현재까지 j번 연속으로 밟고 i번째 계단에 올라갈 때 얻을 수 있는 점수의 최댓값, i번째 계단은 반드시 밟아야함
    # 따라서 j는 1, 2일 수 밖에 없음(세번까지 연속해서 계단을 밟을 수 없다는 조건)
    # 계단 개수와 i가 맞기 위해 d[0]은 dummy 취급
    d = [[0] * (n + 1) for _ in range(n + 1)]

    # 초기값 설정
    d[1][1] = steps[1]
    d[1][2] = 0  # 현재까지 2번 연속으로 밟고 첫번째 계단에 올라가는 경우는 없음
    d[2][1] = steps[2]
    d[2][2] = steps[1] + steps[2]

    # 3층부터 진행
    for k in range(3, n + 1):
        # 현재까지 1번 연속으로 밟았다면, k-1번째 계단은 밟지 않았음
        # 계단을 1번 또는 2번 연속으로 밟은 후 k-2번째 계단에 갔을 때 얻은 최대 점수에 k번째 계단의 점수를 더한 값
        d[k][1] = max(d[k - 2][1], d[k - 2][2]) + steps[k]
        # 현재까지 2번 연속으로 밟았으면, k-1번째 계단은 반드시 밟았음
        # 계단을 세번 연속으로 밟을 수 없으므로, k-1번째 계단으로 가기까지 연속으로 1번의 계단만 밟음
        d[k][2] = d[k - 1][1] + steps[k]

    # n번째 계단에 도달했을 때, 그 전까지 1/2번 연속으로 계단 밟은 경우 중 큰 점수 출력
    print(max(d[n][1], d[n][2]))


if __name__ == '__main__':
    main()
